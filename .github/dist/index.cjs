"use strict";var N=Object.create;var g=Object.defineProperty;var $=Object.getOwnPropertyDescriptor;var H=Object.getOwnPropertyNames;var P=Object.getPrototypeOf,T=Object.prototype.hasOwnProperty;var R=(e,t)=>{for(var s in t)g(e,s,{get:t[s],enumerable:!0})},c=(e,t,s,n)=>{if(t&&typeof t=="object"||typeof t=="function")for(let i of H(t))!T.call(e,i)&&i!==s&&g(e,i,{get:()=>t[i],enumerable:!(n=$(t,i))||n.enumerable});return e};var v=(e,t,s)=>(s=e!=null?N(P(e)):{},c(t||!e||!e.__esModule?g(s,"default",{value:e,enumerable:!0}):s,e)),k=e=>c(g({},"__esModule",{value:!0}),e);var I={};R(I,{generateChangelog:()=>D});module.exports=k(I);var A=v(require("simple-git"),1);var l="BREAKING CHANGES",u="Features",h="Bug Fixes";function f(e){return e.toLowerCase().replace(/\s/gm,"-")}function o({options:e}){return e.module?`${f(e.module)}-v`:"v"}function x({prevTag:e,options:t}){return e==null?void 0:e.replace(o({options:t}),"")}function C({prevVersion:e,changes:t}){if(!e)return console.log("No previous tag, using 1.0.0"),"1.0.0";let[s,n,i]=e.split(".").map(Number);return console.log(`Previous version: ${s}.${n}.${i}`),t.breakingChanges.length>0?(s++,n=0,i=0):t.features.length>0?(n++,i=0):t.fixes.length>0&&i++,`${s}.${n}.${i}`}async function d({git:e,options:t}){let s=(await e.tags()).all.reverse();console.log("Tags:",s);let n=o({options:t});console.log(`Finding latest tag that starts with "${n}"`);let i=s.find(r=>r.startsWith(n));return console.log(`Previous tag: ${i}`),i}async function E({git:e,prevTag:t,options:s}){let n;return t?(console.log("Getting commits since previous tag"),n=await e.log({from:t,to:"HEAD"})):(console.log("Getting all commits"),n=await e.log()),n.all.filter(_(s)).reverse()}function _(e){let t;if(e.module){let s=e.scopes??[f(e.module)];t=new RegExp(`^(feat!?|fix)\\((${s.join("|")})\\)`,"m")}else t=new RegExp("^(feat!?|fix)","m");return s=>t.test(s.message)}async function D(e={},t=(0,A.default)()){console.log("Options:",e);let s=await d({git:t,options:e}),n=x({prevTag:s,options:e}),i=await E({git:t,prevTag:s,options:e}),r=F({commits:i}),G=b({changes:r,options:e}),a=C({prevVersion:n,changes:r}),O=o({options:e})+a,p={skipped:n===a,changelog:G,prevTag:s,prevVersion:n,nextTag:O,nextVersion:a};return console.log("Results:",p),p}function F({commits:e}){let t={fixes:[],features:[],breakingChanges:[]};for(let s of e){if(s.message.startsWith("feat")){let n=w(s);t.breakingChanges.push(...n)}s.message.startsWith("feat")?t.features.push(s):t.fixes.push(s)}return t}function b({changes:e,options:t}){let s=[];if(t.prefix&&s.push(t.prefix.trim()),e.features.length>0){let n=t.fixHeading??u;s.push("",`### ${n}`,"",...e.features.map(m))}if(e.fixes.length>0){let n=t.fixHeading??h;s.push("",`### ${n}`,"",...e.fixes.map(m))}if(e.breakingChanges.length>0){let n=t.breakingChangeHeading??l;s.push("",`### ${n}`,"",...e.breakingChanges.map(m))}return t.suffix&&s.push(t.suffix.trim()),s.join(`
`).trim()}function m(e){let s=/.*\((.*?)\):\s*?(.*)/.exec(e.message);if(s)return`- **${s[1]}:** ${s[2].trim()} (${e.hash})`;let i=/.*?:\s*?(.*)/.exec(e.message);if(i)return`- ${i[1].trim()} (${e.hash})`;throw Error("Could not parse commit: "+e.message)}function w(e){let t=[];return e.message.includes("!:")&&t.push(e),e.body.split(`
`).forEach(s=>{s.startsWith("BREAKING CHANGE:")&&t.push({message:s,hash:e.hash})}),t}0&&(module.exports={generateChangelog});
